## 2.2 Hierarchical Data and the Closure Property


#### Exercise 2.17

```
(define (last-pair items) 
   (let ((rest (cdr items))) 
     (if (null? rest) 
         items 
         (last-pair rest)))) 
```

#### Exercise 2.18

```

(define (reverse list)
  (if (null? (cdr list))
      list
      (append (reverse (cdr list))
              (cons (car list) nil))))
```

#### Exercise 2.19

```

(define (cc amount coin-values)
         (cond ((= amount 0) 1)
               ((or (< amount 0) (no-more? coin-values)) 0)
               (else
                (+ (cc amount 
                       (except-first-denomination coin-values))
                   (cc (- amount
                          (first-denomination coin-values))
                       coin-values)))))

(define (no-more? coin-values)
  (null? coin-values))

(define (first-denomination coin-values)
  (car coin-values))

(define (except-first-denomination coin-values)
  (cdr coin-values))


```


#### Exercise 2.20

```
(define (same-parity head . list)
  (define (helper list number)
    (cond ((null? list) nil)
          ((= number (remainder (car list) 2)) 
           (cons (car list) (helper (cdr list) number)))
       (else (helper (cdr list) number))))
  (cons head (helper list (remainder head 2))))


```



#### Exercise 2.22
```
(define (square-list items)
  (if (null? items)
      nil
      (cons ((lambda (x) (* x x)) (car items))
            (square-list (cdr items)))))

(define (square-list items)
  (map (lambda (x) (* x x)) items))
```

#### Exercise 2.23

```

(define (for-each proc items)
  (cond ((not (null? items))
      (proc (car items))
      (for-each proc (cdr items)))))
```

#### Exercise 2.24
The result is 
```
(1 (2 (3 4)))
```

#### Exercise 2.25

1.

```
(define x (list 1 3 (list 5 7) 9))

(car (cdr (car (cdr (cdr x)))))
```

2.

```
(define y (list (list 7)))

(car (car y))
```

3.

```
(define z (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))

(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
```

#### Exercise 2.26

```
(define x (list 1 2 3))

(define y (list 4 5 6))

(append x y) => (1 2 3 4 5 6)

(cons x y) => ((1 2 3) 4 5 6)

(list x y) => ((1 2 3) (4 5 6))
```
