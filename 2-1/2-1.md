# SICP 

## 2.1 Introduction to Data Abstraction

In this section, the book introduces a power strategy called *wishful thinking* by implementing serveral arithmetic operations for rational number.

It assumes that we have already implemented the constructor and the selector for rational number, and use them to do the following operations: add, subtract, multiply, divide and test equality.

Assuming x is a rational number,

`numer x ` returns the numerator of x

`denom x` returns the denominator of x

`make-rat a b` returns the rational number whose numerator is the integer x and who denominator is the integer b


***

Now the book introduces the *pair* data type, which has three primitive operators: cons, car and cdr.

By using pair, we can represent rational number like this:

```
(define (make-rat n d) (cons n d))

(define (numer x) (car x))

(define (denum x) (cdr x))

```

Then we can do something like this

```
(define one-half (make-rat 1 2))

(add-rat one-half one-half)

```

There is a problem about this implementation:

if we do `(add-rat one-third one-third)`, instead of 2/3, the program returns 6/9, which is not really what we want.

To resolve this, we need to modify our constructor

```
(define (make-rat n d)
(let ((g (gcd n d)))
	(cons (/ n g) (/d g))))
```

We need to get the greatest common divisor of two integers, and use it to reduce the numerator and the denominator to lowest term before constructing the pair.

#### Exercise 2.1

```
((define (make-rat n d)
  
  (define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

  (define (make-rat-reduce n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  
  (cond ((and (< n 0) (< d 0)) (make-rat-reduce (- n) (- d)))
        ((and (> n 0) (< d 0)) (make-rat-reduce (- n) (- d)))
        (else (make-rat-reduce n d))))

```
Another concise solution would be:

```
(define (make-rat n d)
  (define (gcd a b)
    (if (= b 0)
      a
      (gcd b (remainder a b))))
  
  (define (make-rat-reduce n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  
  (if (< d 0)
      (make-rat-reduce (- n) (- d))
      (make-rat-reduce n d)))

```

This is based on the observation that when d is negative, we can toggle the sign of n and the sign of d, or we leave them untouched.


